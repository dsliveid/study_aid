# 音频采集技术原理

## 目录

1. [Windows音频子系统概述](#1-windows音频子系统概述)
2. [WASAPI详解](#2-wasapi详解)
3. [麦克风音频采集原理](#3-麦克风音频采集原理)
4. [系统音频采集原理](#5-系统音频采集原理)
5. [音频设备管理](#6-音频设备管理)
6. [音频流处理](#7-音频流处理)
7. [Python实现方案](#8-python实现方案)

---

## 1. Windows音频子系统概述

### 1.1 音频子系统架构

Windows音频子系统是一个分层架构，从底层硬件到高层应用API：

```
应用层
    ↓
高层API（WASAPI、DirectSound、MME）
    ↓
音频引擎（Audio Engine）
    ↓
音频驱动（Audio Driver）
    ↓
硬件层（Audio Hardware）
```

### 1.2 音频API演进

| API | 版本 | 特点 | 状态 |
|-----|------|------|------|
| MME | Windows 3.1 | 最早的多媒体API | 已过时 |
| DirectSound | Windows 95 | 低延迟游戏音频 | 已过时 |
| WASAPI | Windows Vista | 现代音频API | 推荐 |
| Windows Audio Graph | Windows 10 | 新一代音频API | 新技术 |

### 1.3 WASAPI优势

- **低延迟**：直接访问音频引擎
- **高质量**：支持高精度音频
- **灵活性**：支持多种模式
- **安全性**：音频会话隔离
- **兼容性**：向后兼容旧API

---

## 2. WASAPI详解

### 2.1 WASAPI架构

WASAPI（Windows Audio Session API）是Windows Vista引入的现代音频API：

```
MMDeviceEnumerator
    ↓
IMMDevice (音频设备)
    ↓
IAudioClient (音频客户端)
    ↓
IAudioCaptureClient / IAudioRenderClient
```

### 2.2 核心接口

#### 2.2.1 MMDeviceEnumerator

**功能**：枚举和管理音频设备

**主要方法**：
```cpp
// 枚举所有音频设备
EnumAudioEndpoints(
    EDataFlow dataFlow,  // eCapture（输入）或 eRender（输出）
    DWORD dwStateMask,    // 设备状态掩码
    IMMDeviceCollection **ppDevices
)

// 获取默认音频设备
GetDefaultAudioEndpoint(
    EDataFlow dataFlow,
    ERole role,           // eConsole, eMultimedia, eCommunications
    IMMDevice **ppDevice
)
```

**Python实现**：
```python
import sounddevice as sd

# 枚举所有设备
devices = sd.query_devices()

# 获取默认输入设备
default_input = sd.default.device[0]

# 获取默认输出设备
default_output = sd.default.device[1]
```

#### 2.2.2 IMMDevice

**功能**：表示单个音频设备

**主要属性**：
- 设备ID
- 设备名称
- 设备状态
- 音频格式支持

**Python实现**：
```python
import sounddevice as sd

# 获取设备信息
device_info = sd.query_devices(device_index)
print(f"设备名称: {device_info['name']}")
print(f"采样率: {device_info['default_samplerate']}")
print(f"最大输入声道: {device_info['max_input_channels']}")
print(f"最大输出声道: {device_info['max_output_channels']}")
```

#### 2.2.3 IAudioClient

**功能**：创建和管理音频会话

**主要方法**：
```cpp
// 初始化音频客户端
Initialize(
    AUDCLNT_SHAREMODE ShareMode,  // 共享模式或独占模式
    DWORD StreamFlags,             // 流标志
    hnsBufferDuration,             // 缓冲区持续时间
    hnsPeriodicity,                // 周期性（仅独占模式）
    const WAVEFORMATEX *pFormat,   // 音频格式
    LPCGUID AudioSessionGuid       // 音频会话GUID
)

// 获取服务接口
GetService(
    const IID &iid,
    void **ppv
)
```

**Python实现**：
```python
import sounddevice as sd

# 创建音频流
stream = sd.InputStream(
    device=device_index,
    channels=1,
    samplerate=16000,
    callback=audio_callback
)
```

#### 2.2.4 IAudioCaptureClient

**功能**：从音频设备捕获数据

**主要方法**：
```cpp
// 获取缓冲区
GetBuffer(
    BYTE **ppData,
    UINT32 *pNumFramesToRead,
    DWORD *pdwFlags,
    UINT64 *pu64DevicePosition,
    UINT64 *pu64QPCPosition
)

// 释放缓冲区
ReleaseBuffer(UINT32 NumFramesRead)
```

**Python实现**：
```python
def audio_callback(indata, frames, time, status):
    if status:
        print(f"音频回调状态: {status}")
    # 处理音频数据
    process_audio(indata)
```

### 2.3 WASAPI模式

#### 2.3.1 共享模式（Shared Mode）

**特点**：
- 多个应用共享音频设备
- 系统自动混音
- 延迟适中
- 兼容性好

**适用场景**：
- 普通音频应用
- 不需要极低延迟
- 需要与其他应用共存

**配置**：
```python
import sounddevice as sd

# 共享模式（默认）
stream = sd.InputStream(
    device=device_index,
    channels=1,
    samplerate=16000,
    callback=audio_callback
)
```

#### 2.3.2 独占模式（Exclusive Mode）

**特点**：
- 应用独占音频设备
- 最低延迟
- 最高质量
- 需要特殊权限

**适用场景**：
- 专业音频应用
- 需要极低延迟
- 需要最高音质

**配置**：
```python
# 独占模式需要使用pyaudio
import pyaudio

p = pyaudio.PyAudio()
stream = p.open(
    format=pyaudio.paInt16,
    channels=1,
    rate=16000,
    input=True,
    input_device_index=device_index,
    frames_per_buffer=1024
)
```

#### 2.3.3 环回模式（Loopback Mode）

**特点**：
- 捕获系统输出音频
- 不影响系统音频输出
- 需要管理员权限（某些情况）

**适用场景**：
- 录制系统音频
- 屏幕录制配音
- 音频监控

**配置**：
```python
import sounddevice as sd

# 环回模式
def loopback_callback(indata, frames, time, status):
    if status:
        print(f"环回回调状态: {status}")
    # 处理系统音频
    process_system_audio(indata)

# 获取输出设备
output_devices = sd.query_devices()
for i, device in enumerate(output_devices):
    if device['max_output_channels'] > 0:
        print(f"输出设备 {i}: {device['name']}")

# 创建环回流
stream = sd.InputStream(
    device=output_device_index,
    channels=2,  # 系统音频通常是立体声
    samplerate=44100,
    callback=loopback_callback
)
```

---

## 3. 麦克风音频采集原理

### 3.1 麦克风工作原理

#### 3.1.1 模拟信号转换

```
声波 → 麦克风振膜 → 模拟电信号 → ADC → 数字音频信号
```

**过程说明**：
1. **声波**：空气振动产生声波
2. **麦克风振膜**：声波使振膜振动
3. **模拟电信号**：振膜振动产生电压变化
4. **ADC（模数转换器）**：将模拟信号转换为数字信号
5. **数字音频信号**：PCM格式的数字音频

#### 3.1.2 数字音频参数

| 参数 | 说明 | 常用值 |
|------|------|--------|
| 采样率 | 每秒采样次数 | 8000, 16000, 44100, 48000 Hz |
| 位深 | 每个采样的精度 | 16-bit, 24-bit, 32-bit |
| 声道数 | 音频通道数 | 1（单声道）, 2（立体声） |

### 3.2 麦克风采集流程

```
1. 设备枚举
    ↓
2. 设备选择
    ↓
3. 音频会话创建
    ↓
4. 流格式配置
    ↓
5. 缓冲区分配
    ↓
6. 实时采集
    ↓
7. 数据处理
```

### 3.3 详细实现步骤

#### 步骤1：设备枚举

```python
import sounddevice as sd

def enumerate_microphones():
    """枚举所有麦克风设备"""
    devices = sd.query_devices()
    microphones = []

    for i, device in enumerate(devices):
        if device['max_input_channels'] > 0:
            microphones.append({
                'index': i,
                'name': device['name'],
                'channels': device['max_input_channels'],
                'sample_rate': device['default_samplerate']
            })

    return microphones

# 使用示例
mics = enumerate_microphones()
for mic in mics:
    print(f"麦克风 {mic['index']}: {mic['name']}")
    print(f"  声道数: {mic['channels']}")
    print(f"  默认采样率: {mic['sample_rate']} Hz")
```

#### 步骤2：设备选择

```python
def select_microphone(microphones):
    """选择麦克风设备"""
    print("可用麦克风设备:")
    for mic in microphones:
        print(f"  {mic['index']}: {mic['name']}")

    choice = input("请选择麦克风编号: ")
    selected_index = int(choice)

    return selected_index

# 使用示例
mics = enumerate_microphones()
selected_mic = select_microphone(mics)
```

#### 步骤3：音频会话创建

```python
import sounddevice as sd
import queue

class MicrophoneCapture:
    def __init__(self, device_index=None, sample_rate=16000, channels=1):
        self.device_index = device_index
        self.sample_rate = sample_rate
        self.channels = channels
        self.audio_queue = queue.Queue(maxsize=100)
        self.stream = None
        self.is_recording = False

    def start(self):
        """开始采集"""
        def callback(indata, frames, time, status):
            if status:
                print(f"音频回调状态: {status}")
            self.audio_queue.put(indata.copy())

        self.stream = sd.InputStream(
            device=self.device_index,
            channels=self.channels,
            samplerate=self.sample_rate,
            callback=callback
        )
        self.stream.start()
        self.is_recording = True
        print(f"开始采集麦克风音频 (设备: {self.device_index})")

    def stop(self):
        """停止采集"""
        if self.stream:
            self.stream.stop()
            self.stream.close()
            self.stream = None
        self.is_recording = False
        print("停止采集")

    def get_audio_data(self, timeout=1.0):
        """获取音频数据"""
        try:
            return self.audio_queue.get(timeout=timeout)
        except queue.Empty:
            return None

# 使用示例
capture = MicrophoneCapture(device_index=1, sample_rate=16000, channels=1)
capture.start()

# 采集音频
for i in range(10):
    audio_data = capture.get_audio_data()
    if audio_data is not None:
        print(f"采集到音频数据: {audio_data.shape}")

capture.stop()
```

#### 步骤4：流格式配置

```python
def configure_audio_format(sample_rate=16000, channels=1, dtype='float32'):
    """配置音频格式"""
    audio_format = {
        'sample_rate': sample_rate,
        'channels': channels,
        'dtype': dtype,
        'blocksize': 1024
    }
    return audio_format

# 使用示例
audio_format = configure_audio_format(
    sample_rate=16000,
    channels=1,
    dtype='float32'
)
print(f"音频格式: {audio_format}")
```

#### 步骤5：缓冲区管理

```python
import numpy as np

class AudioBuffer:
    def __init__(self, max_size=1024):
        self.buffer = np.zeros(max_size, dtype=np.float32)
        self.max_size = max_size
        self.write_index = 0
        self.read_index = 0

    def write(self, data):
        """写入数据"""
        data_len = len(data)
        available_space = self.max_size - (self.write_index - self.read_index)

        if data_len > available_space:
            print("警告: 缓冲区溢出")
            data_len = available_space

        end_index = (self.write_index + data_len) % self.max_size

        if end_index > self.write_index:
            self.buffer[self.write_index:end_index] = data[:data_len]
        else:
            first_part = self.max_size - self.write_index
            self.buffer[self.write_index:] = data[:first_part]
            self.buffer[:end_index] = data[first_part:]

        self.write_index = end_index

    def read(self, num_samples):
        """读取数据"""
        available_data = self.write_index - self.read_index

        if num_samples > available_data:
            num_samples = available_data

        end_index = (self.read_index + num_samples) % self.max_size

        if end_index > self.read_index:
            data = self.buffer[self.read_index:end_index].copy()
        else:
            first_part = self.max_size - self.read_index
            data = np.concatenate([
                self.buffer[self.read_index:].copy(),
                self.buffer[:end_index].copy()
            ])

        self.read_index = end_index
        return data

# 使用示例
buffer = AudioBuffer(max_size=1024)
buffer.write(np.random.randn(100).astype(np.float32))
data = buffer.read(50)
print(f"读取数据: {data.shape}")
```

---

## 4. 系统音频采集原理

### 4.1 WASAPI Loopback模式

#### 4.1.1 Loopback模式原理

```
应用A → 音频引擎 → 扬声器
              ↓
         Loopback捕获
              ↓
          采集应用
```

**工作原理**：
1. 系统音频通过音频引擎输出到扬声器
2. Loopback模式在音频引擎处捕获音频
3. 捕获的音频与输出到扬声器的音频相同
4. 不影响系统音频的正常输出

#### 4.1.2 Loopback特点

| 特性 | 说明 |
|------|------|
| 音频源 | 系统输出音频 |
| 音频格式 | 与输出设备相同 |
| 延迟 | 极低 |
| 权限 | 可能需要管理员权限 |
| DRM限制 | 受保护的音频可能无法捕获 |

### 4.2 系统音频采集流程

```
1. 枚举输出设备
    ↓
2. 选择目标设备
    ↓
3. 创建Loopback会话
    ↓
4. 配置音频参数
    ↓
5. 实时捕获
    ↓
6. 数据处理
```

### 4.3 详细实现步骤

#### 步骤1：枚举输出设备

```python
import sounddevice as sd

def enumerate_output_devices():
    """枚举所有输出设备"""
    devices = sd.query_devices()
    output_devices = []

    for i, device in enumerate(devices):
        if device['max_output_channels'] > 0:
            output_devices.append({
                'index': i,
                'name': device['name'],
                'channels': device['max_output_channels'],
                'sample_rate': device['default_samplerate']
            })

    return output_devices

# 使用示例
outputs = enumerate_output_devices()
for output in outputs:
    print(f"输出设备 {output['index']}: {output['name']}")
    print(f"  声道数: {output['channels']}")
    print(f"  默认采样率: {output['sample_rate']} Hz")
```

#### 步骤2：创建Loopback会话

```python
import sounddevice as sd
import queue
import numpy as np

class SystemAudioCapture:
    def __init__(self, device_index=None, sample_rate=44100, channels=2):
        self.device_index = device_index
        self.sample_rate = sample_rate
        self.channels = channels
        self.audio_queue = queue.Queue(maxsize=100)
        self.stream = None
        self.is_recording = False

    def start(self):
        """开始采集系统音频"""
        def callback(indata, frames, time, status):
            if status:
                print(f"环回回调状态: {status}")
            self.audio_queue.put(indata.copy())

        self.stream = sd.InputStream(
            device=self.device_index,
            channels=self.channels,
            samplerate=self.sample_rate,
            callback=callback
        )
        self.stream.start()
        self.is_recording = True
        print(f"开始采集系统音频 (设备: {self.device_index})")

    def stop(self):
        """停止采集"""
        if self.stream:
            self.stream.stop()
            self.stream.close()
            self.stream = None
        self.is_recording = False
        print("停止采集")

    def get_audio_data(self, timeout=1.0):
        """获取音频数据"""
        try:
            return self.audio_queue.get(timeout=timeout)
        except queue.Empty:
            return None

# 使用示例
outputs = enumerate_output_devices()
if outputs:
    capture = SystemAudioCapture(
        device_index=outputs[0]['index'],
        sample_rate=44100,
        channels=2
    )
    capture.start()

    # 采集音频
    for i in range(10):
        audio_data = capture.get_audio_data()
        if audio_data is not None:
            print(f"采集到系统音频: {audio_data.shape}")

    capture.stop()
```

### 4.4 系统音频处理注意事项

#### 4.4.1 音频格式转换

系统音频通常是立体声（2声道），需要转换为单声道：

```python
import numpy as np

def stereo_to_mono(audio):
    """立体声转单声道"""
    if len(audio.shape) == 1:
        return audio
    return np.mean(audio, axis=1)

# 使用示例
stereo_audio = np.random.randn(100, 2).astype(np.float32)
mono_audio = stereo_to_mono(stereo_audio)
print(f"立体声: {stereo_audio.shape} → 单声道: {mono_audio.shape}")
```

#### 4.4.2 采样率转换

系统音频采样率通常是44100Hz或48000Hz，需要转换为16000Hz：

```python
from scipy import signal
import numpy as np

def resample_audio(audio, original_rate, target_rate):
    """重采样"""
    if original_rate == target_rate:
        return audio

    number_of_samples = round(len(audio) * float(target_rate) / original_rate)
    resampled_audio = signal.resample(audio, number_of_samples)
    return resampled_audio.astype(np.float32)

# 使用示例
audio_44k = np.random.randn(44100).astype(np.float32)
audio_16k = resample_audio(audio_44k, 44100, 16000)
print(f"44100Hz: {len(audio_44k)} → 16000Hz: {len(audio_16k)}")
```

---

## 5. 音频设备管理

### 5.1 设备状态监控

```python
import sounddevice as sd

def monitor_devices():
    """监控设备状态"""
    devices = sd.query_devices()

    print("设备状态:")
    for i, device in enumerate(devices):
        status = "可用"
        if device['max_input_channels'] == 0 and device['max_output_channels'] == 0:
            status = "不可用"

        print(f"  设备 {i}: {device['name']}")
        print(f"    状态: {status}")
        print(f"    输入声道: {device['max_input_channels']}")
        print(f"    输出声道: {device['max_output_channels']}")

# 使用示例
monitor_devices()
```

### 5.2 设备热插拔处理

```python
import sounddevice as sd
import time

class DeviceMonitor:
    def __init__(self):
        self.last_devices = self.get_devices()

    def get_devices(self):
        """获取当前设备列表"""
        devices = sd.query_devices()
        return [(i, device['name']) for i, device in enumerate(devices)]

    def check_changes(self):
        """检查设备变化"""
        current_devices = self.get_devices()

        if current_devices != self.last_devices:
            print("检测到设备变化:")
            self.print_changes(self.last_devices, current_devices)
            self.last_devices = current_devices
            return True

        return False

    def print_changes(self, old_devices, new_devices):
        """打印设备变化"""
        old_dict = dict(old_devices)
        new_dict = dict(new_devices)

        # 新增设备
        for index, name in new_devices:
            if index not in old_dict:
                print(f"  新增设备: {name}")

        # 移除设备
        for index, name in old_devices:
            if index not in new_dict:
                print(f"  移除设备: {name}")

# 使用示例
monitor = DeviceMonitor()

try:
    while True:
        if monitor.check_changes():
            print("设备列表已更新")
        time.sleep(1)
except KeyboardInterrupt:
    print("停止监控")
```

---

## 6. 音频流处理

### 6.1 音频流架构

```
音频采集线程
    ↓
音频缓冲队列
    ↓
音频处理线程
    ↓
识别线程
    ↓
结果队列
```

### 6.2 多线程实现

```python
import threading
import queue
import numpy as np
import sounddevice as sd

class AudioStreamProcessor:
    def __init__(self, sample_rate=16000, channels=1):
        self.sample_rate = sample_rate
        self.channels = channels
        self.audio_queue = queue.Queue(maxsize=100)
        self.result_queue = queue.Queue(maxsize=100)
        self.is_running = False
        self.capture_thread = None
        self.process_thread = None

    def capture_callback(self, indata, frames, time, status):
        """音频采集回调"""
        if status:
            print(f"采集状态: {status}")
        self.audio_queue.put(indata.copy())

    def capture_worker(self):
        """音频采集线程"""
        def callback(indata, frames, time, status):
            self.capture_callback(indata, frames, time, status)

        stream = sd.InputStream(
            channels=self.channels,
            samplerate=self.sample_rate,
            callback=callback
        )
        stream.start()

        while self.is_running:
            pass

        stream.stop()
        stream.close()

    def process_worker(self):
        """音频处理线程"""
        while self.is_running:
            try:
                audio_data = self.audio_queue.get(timeout=1.0)

                # 处理音频数据
                processed_data = self.process_audio(audio_data)

                # 发送到结果队列
                self.result_queue.put(processed_data)

            except queue.Empty:
                continue

    def process_audio(self, audio_data):
        """处理音频数据"""
        # 这里可以添加音频处理逻辑
        return audio_data

    def start(self):
        """启动处理"""
        self.is_running = True
        self.capture_thread = threading.Thread(target=self.capture_worker)
        self.process_thread = threading.Thread(target=self.process_worker)

        self.capture_thread.start()
        self.process_thread.start()
        print("音频流处理已启动")

    def stop(self):
        """停止处理"""
        self.is_running = False

        if self.capture_thread:
            self.capture_thread.join()
        if self.process_thread:
            self.process_thread.join()

        print("音频流处理已停止")

    def get_processed_audio(self, timeout=1.0):
        """获取处理后的音频"""
        try:
            return self.result_queue.get(timeout=timeout)
        except queue.Empty:
            return None

# 使用示例
processor = AudioStreamProcessor(sample_rate=16000, channels=1)
processor.start()

# 获取处理后的音频
for i in range(10):
    audio_data = processor.get_processed_audio()
    if audio_data is not None:
        print(f"处理后的音频: {audio_data.shape}")

processor.stop()
```

---

## 7. 音频质量控制

### 7.1 音频质量指标

| 指标 | 说明 | 目标值 |
|------|------|--------|
| 采样率 | 每秒采样次数 | 16000 Hz |
| 位深 | 采样精度 | 16-bit 或 32-bit float |
| 信噪比 | 信号与噪声比 | > 60 dB |
| 失真度 | 音频失真程度 | < 1% |
| 延迟 | 音频采集延迟 | < 100 ms |

### 7.2 音频质量检测

```python
import numpy as np

def calculate_snr(audio, noise_floor=0.001):
    """计算信噪比"""
    signal_power = np.mean(audio ** 2)
    noise_power = noise_floor ** 2
    snr = 10 * np.log10(signal_power / noise_power)
    return snr

def calculate_rms(audio):
    """计算均方根值"""
    return np.sqrt(np.mean(audio ** 2))

def detect_clipping(audio, threshold=0.95):
    """检测音频削波"""
    clipped = np.abs(audio) > threshold
    clipping_ratio = np.sum(clipped) / len(audio)
    return clipping_ratio

# 使用示例
audio = np.random.randn(16000).astype(np.float32) * 0.5

snr = calculate_snr(audio)
rms = calculate_rms(audio)
clipping = detect_clipping(audio)

print(f"信噪比: {snr:.2f} dB")
print(f"均方根: {rms:.4f}")
print(f"削波比例: {clipping:.2%}")
```

---

## 8. Python实现方案

### 8.1 完整的音频采集类

```python
import sounddevice as sd
import queue
import numpy as np
from typing import Optional, List, Dict, Callable

class AudioCapture:
    """音频采集类"""

    def __init__(self, sample_rate: int = 16000, channels: int = 1):
        self.sample_rate = sample_rate
        self.channels = channels
        self.audio_queue = queue.Queue(maxsize=100)
        self.is_recording = False
        self.stream = None
        self.callback = None

    def list_microphone_devices(self) -> List[Dict]:
        """列出所有麦克风设备"""
        devices = sd.query_devices()
        mic_devices = []

        for i, device in enumerate(devices):
            if device['max_input_channels'] > 0:
                mic_devices.append({
                    'index': i,
                    'name': device['name'],
                    'channels': device['max_input_channels'],
                    'sample_rate': device['default_samplerate']
                })

        return mic_devices

    def list_system_audio_devices(self) -> List[Dict]:
        """列出所有系统音频输出设备"""
        devices = sd.query_devices()
        sys_devices = []

        for i, device in enumerate(devices):
            if device['max_output_channels'] > 0:
                sys_devices.append({
                    'index': i,
                    'name': device['name'],
                    'channels': device['max_output_channels'],
                    'sample_rate': device['default_samplerate']
                })

        return sys_devices

    def start_microphone_capture(self, device_index: Optional[int] = None):
        """开始麦克风采集"""
        def callback(indata, frames, time, status):
            if status:
                print(f"音频回调状态: {status}")
            self.audio_queue.put(indata.copy())

            if self.callback:
                self.callback(indata.copy())

        self.stream = sd.InputStream(
            device=device_index,
            channels=self.channels,
            samplerate=self.sample_rate,
            callback=callback
        )
        self.stream.start()
        self.is_recording = True
        print(f"开始采集麦克风音频 (设备: {device_index})")

    def start_system_audio_capture(self, device_index: int):
        """开始系统音频采集（WASAPI Loopback）"""
        def callback(indata, frames, time, status):
            if status:
                print(f"环回回调状态: {status}")
            self.audio_queue.put(indata.copy())

            if self.callback:
                self.callback(indata.copy())

        self.stream = sd.InputStream(
            device=device_index,
            channels=2,
            samplerate=44100,
            callback=callback
        )
        self.stream.start()
        self.is_recording = True
        print(f"开始采集系统音频 (设备: {device_index})")

    def stop_capture(self):
        """停止采集"""
        if self.stream:
            self.stream.stop()
            self.stream.close()
            self.stream = None
        self.is_recording = False
        print("停止采集")

    def get_audio_data(self, timeout: float = 1.0) -> Optional[np.ndarray]:
        """获取音频数据"""
        try:
            return self.audio_queue.get(timeout=timeout)
        except queue.Empty:
            return None

    def set_callback(self, callback: Callable[[np.ndarray], None]):
        """设置音频回调函数"""
        self.callback = callback

    def is_active(self) -> bool:
        """检查是否正在采集"""
        return self.is_recording

# 使用示例
if __name__ == "__main__":
    capture = AudioCapture(sample_rate=16000, channels=1)

    # 列出设备
    print("麦克风设备:")
    for mic in capture.list_microphone_devices():
        print(f"  {mic['index']}: {mic['name']}")

    print("\n系统音频设备:")
    for sys_dev in capture.list_system_audio_devices():
        print(f"  {sys_dev['index']}: {sys_dev['name']}")

    # 开始采集
    capture.start_microphone_capture(device_index=1)

    # 采集音频
    for i in range(10):
        audio_data = capture.get_audio_data()
        if audio_data is not None:
            print(f"采集到音频数据: {audio_data.shape}")

    # 停止采集
    capture.stop_capture()
```

---

## 总结

本文档详细介绍了Windows音频采集技术原理，包括：

1. **Windows音频子系统概述**：音频子系统的分层架构和API演进
2. **WASAPI详解**：核心接口、模式和配置方法
3. **麦克风音频采集原理**：从模拟信号到数字信号的转换过程
4. **系统音频采集原理**：WASAPI Loopback模式的工作机制
5. **音频设备管理**：设备枚举、状态监控和热插拔处理
6. **音频流处理**：多线程架构和缓冲区管理
7. **音频质量控制**：质量指标和检测方法
8. **Python实现方案**：完整的音频采集类实现

通过本文档，开发者可以深入理解Windows音频采集的技术原理，为实时语音识别系统的音频采集模块开发提供理论指导。

---

**文档版本**：v1.0  
**创建日期**：2024-01-01  
**最后更新**：2024-01-01
